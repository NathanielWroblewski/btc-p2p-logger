{
  "name": "p2p-manager",
  "version": "0.1.0",
  "description": "Create a peer-to-peer relationship",
  "keywords": [
    "p2p",
    "network",
    "peers",
    "cryptography"
  ],
  "main": "./lib/PeerManager.js",
  "dependencies": {
    "p2p-node": "0.1.x",
    "sha256": "0.1.x"
  },
  "repository": {
    "url": "https://github.com/cryptocoinjs/p2p-manager",
    "type": "git"
  },
  "author": {
    "name": "Brooks Boyd",
    "email": "boydb@midnightdesign.ws"
  },
  "readme": "# P2P Manager\nManage a network of peers in a peer-to-peer network.\n\n## Messages\n\n### `peerConnect`, `peerEnd`, `peerError`\nEmitted when an active Peer emits a `connect`, `end` or `error` message respectively, and the data payload is the same:\n\n```\n{\n  peer: Peer\n}\n```\n\n### `peerMessage`\nEmitted when an active Peer sends a `message` event.\n\n```\n{\n  peer: Peer,\n  command: String,\n  data: Raw payload as binary data\n}\n```\n\n### `commandMessage`\nAn alternate version of the `peerMessage` event; in these events, the command of the message is used as the event name (i.e. command `'foo'` would cause a `fooMessage` event).\n\n```\n{\n  peer: Peer,\n  data: Raw payload as binary data\n}\n```\n\n### `error`\nError message from the PeerManager. The `severity` attribute is one of 'info', 'notice', 'warning', or 'error' (in increasing severity). \n\n```\n{\n  severity: String,\n  message: String\n}\n```\n\n## `PeerManager.send()`\nThe PeerManager allows sending messages to a collection of Peers at once, based on certain criteria. The most common criteria is the \"state\" of the Peer. Each Peer object has a `state` property which is set to `'new'` when first created, `'connecting'` when first opened, and `'connected'` when first `connect` event is heard (before `handleConnect` is called, so that can be overwritten, if desired). Any other states are up to your PeerManager instance to implement.\n\n* `number`: How many peers to send to? Once filtered down, should all or a sub-set be messaged? Pass a Number to send to that many Peers (picked at random). Passing a zero or negative number for this argument sends to all matched Peers.\n* `prop`: (String) Which property of the Peers should be examined?\n* `value`: Value of the property the Peers need to match to be included in the set. Matching is done in a case-insensitive way for strings. Passing an array for this argument requires Peers match any one of the array's values.\n* `cmd`: (String) Message name to be sent to the Peers\n* `payload`: (Buffer) Binary data to be sent to the Peers\n* `answerCmd`: (String) Message name of answering message. If null/false, defaults to all `message` events.\n* `callback`: (function) If provided, is bound to the \"`answerCmd`\" event of the Peers contacted, to await their reply\n\n```js\nPeerManager.send('all', 'state', 'connected', 'hi', new Buffer([1,2,3,4,5])); // Send a message to all connected clients\nPeerManager.send(2, 'state', 'lonely', 'matchmaker', new Buffer([1,2,3,4,5])); // Send a message to a random two Peers who have state=='lonely'\nPeerManager.send(5, 'myProp', [1,5,42,false], 'hi', new Buffer([1,2,3,4,5])); // Send a message to a random five Peers who have myProp equal to either 1, 5 ,42, or false\n```\n\nThe function returns an dictionary of Peers the message was sent to, stored by their UUID.\n\nIf you're expecting a specific answer to your message, there's a few ways you can listen in:\n\n### Listen to only answer messages, from just the filtered peers\nProbably the most common, and the most specific listening type:\n\n```js\nvar m = new PeerManager();\nvar waitForAnswer = function(d) {\n  console.log(d.peer.getUUID()+': has answered', d.data.toString('hex'));\n  d.peer.removeListener('message', this); // This listener doesn't care about further messages\n  delete peers[d.peer.getUUID()]; // Remove this peer from the list of peers who haven't answered yet\n};\n\nvar peers = m.send(2, 'state', 'waiting', 'knock', new Buffer([1,2,3]), 'answer', waitForAnswer);\n\nsetTimeout(function() {\n  // Ten seconds have passed; give up on those who haven't answered\n  for (var uuid in peers) {\n    if (peers.hasOwnProperty(uuid)) {\n      console.log(uuid+' never answered...');\n      peers[uuid].removeListener('message', waitForAnswer);\n    }\n  }\n}, 10000);\n```\n\n### Listen to all messages, from just the filtered Peers \nA good method if you expect the answer you seek to be in the next few messages from those Peers, and the answer might be one of several messages ('answer' or 'error'):\n\n```js\nvar m = new PeerManager();\nvar waitForAnswer = function(d) {\n  if (d.command !== 'answer') return; // Wait for next message...\n  \n  console.log(d.peer.getUUID()+': has answered', d.data.toString('hex'));\n  d.peer.removeListener('message', this); // This listener doesn't care about further messages\n  delete peers[d.peer.getUUID()]; // Remove this peer from the list of peers who haven't answered yet\n};\n\nvar peers = m.send(2, 'state', 'waiting', 'knock', new Buffer([1,2,3]), false, waitForAnswer);\n\nsetTimeout(function() {\n  // Ten seconds have passed; give up on those who haven't answered\n  for (var uuid in peers) {\n    if (peers.hasOwnProperty(uuid)) {\n      console.log(uuid+' never answered...');\n      peers[uuid].removeListener('message', waitForAnswer);\n    }\n  }\n}, 10000);\n```\n\n### Listen to only answer messages, from all Peers\nIf there are lots of other messages being sent around, but very few of the particular answer messages you're looking for, this works well, or if there's a possibility another peer will answer on behalf of the peer you requested from:\n\n```js\nvar m = new PeerManager();\nvar waitForAnswer = function(d) {\n  // Look through our list of peers and see if d.peer is one of them\n  if (peers[d.peer.getUUID()] !== d.peer) return;\n  \n  console.log(d.peer.getUUID()+': has answered', d.data.toString('hex'));\n  delete peers[d.peer.getUUID()]; // Remove this peer from the list of peers who haven't answered yet\n};\nvar peers = m.send(2, 'state', 'waiting', 'knock', new Buffer([1,2,3]));\nm.on('answer', waitForAnswer); // Listen in on all 'answer' messages from all peers\n\nsetTimeout(function() {\n  // Ten seconds have passed; give up on those who haven't answered\n  for (var uuid in peers) {\n    if (peers.hasOwnProperty(uuid)) {\n      console.log(uuid+' never answered...');\n    }\n  }\n  m.removeListener('answer', waitForAnswer);\n}, 10000);\n```\n\n## Peers\nThe PeerManager keeps a list of known Peers to connect to (the \"pool\"), as well as a list of those currently connected (\"active\").\n\nAs your implementation discovers new Peers, use the `PeerManager.addPool(hosts)` method to tell the PeerManager about them. If the number of active Peers is currently below the minimum (`options.minPeers`), a connection will be attempted immediately. Otherwise, they will just be added to the pool. `PeerManager.addActive(hosts)` adds a new peer and attempts to connect to it immediately, regardless if the number of active Peers is above the threshhold.\n\n## Peer lists\nThe `seedPeers` argument of `launch()`, and the `hosts` argument of `addPool()` and `addActive()` are lists of hosts, expressed one of the following ways:\n\n* If it's a String, it's assumed to be the hostname/ip of one host to use; make sure to include a port number as part of the hostname (colon-delimited).\n* If it's an Array, it's looped through and each element inspected.\n* * If it's a String, it's assumed to be a hostname/ip of a host to use.\n* * If it's an Array, index zero is used as host and index one is used as port.\n* * If it's an Object, the `host` property is used as host, and the `port` property is used as port.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cryptocoinjs/p2p-manager/issues"
  },
  "_id": "p2p-manager@0.1.0",
  "_from": "p2p-manager@0.1.x"
}
